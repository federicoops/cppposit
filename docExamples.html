<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>Examples</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">cppposit 1.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">Pages</p><li><a href="docExamples.html">Examples</a></li><li><a href="docBackends.html">Backends</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><main class="content"><h1>Examples</h1>
<p>In the <a href="https://github.com/federicorossifr/cppposit/tree/main/examples">examples folder</a> you can find some ready-to-try examples that deepen on some of the functionalities of the cppposit library and possible integration with other libraries.</p>
<p>You can compile all the examples as follows:</p>
<pre><code class="language-c++">cmake -B builddir
cmake --build builddir --target examples
</code></pre>
<p>You will find the executables as follows:</p>
<pre><code class="language-bash">➜  cppposit git:(main) ✗ tree -L 1 builddir/examples 
builddir/examples
├── example_01_basic
├── example_02_deepinit
├── example_03_stl
├── example_04_eigen
├── example_05_fft
├── example_05_tabulatedposit
├── example_06_logging
├── example_06_pseudosig
├── example_07_pseudotanh
├── example_08_fused
├── example_98_backendhw
└── example_99_debugger
</code></pre>
<h3>Table of Contents</h3>
<ul>
<li><a href="#basic">Basic</a></li>
<li><a href="#deep-initialization">Deep Initialization</a></li>
<li><a href="#standard-template-library">STL</a></li>
<li><a href="#eigen-library">Eigen</a></li>
<li><a href="#fast-fourier-transform">FFT</a></li>
<li><a href="#logging">Logging</a></li>
<li><a href="#pseudo-sigmoid">Pseudo Sigmoid</a></li>
<li><a href="#pseudo-tanh">Pseudo Tanh</a></li>
<li><a href="#fused-operations">Fused Operations</a></li>
<li><a href="#hardware-backend-example">HW Backend</a></li>
</ul>
<h2>Basic</h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
using namespace posit;
#include &lt;posit.h&gt; // include non-tabulated posits

int main() {
    Posit&lt;int32_t, 32, 2, uint32_t, PositSpec::WithInfs&gt; One(1);
    Posit&lt;int32_t, 32, 2, uint32_t, PositSpec::WithInfs&gt; Tiny(0.00000000000000003);
    auto Min = Posit&lt;int32_t, 32, 2, uint32_t, PositSpec::WithInfs&gt;::from_sraw(1);
    auto ot = One - Tiny;
    auto eps = One - One.prev();
    printf(&quot;One val:\t %.23f\n&quot;, (double)One);
    printf(&quot;Tiny val:\t %.23f\n&quot;, (double)Tiny);
    printf(&quot;Epsilon:\t %.23f\n&quot;, (double)eps);
    printf(&quot;Min:\t %.64f\n&quot;, (double)Min);

    printf(&quot;One - tiny:\t %.23f\n&quot;, (double)(ot));
    printf(&quot;One - eps:\t %.23f\n&quot;, (double)(One - eps));

    printf(&quot;One previous:\t %.23f\n&quot;, (double)One.prev());

    std::cout &lt;&lt; eps.v &lt;&lt; &quot; &quot; &lt;&lt; Tiny.v &lt;&lt; std::endl;
}
</code></pre>
<h2>Deep initialization</h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

#include &lt;posit.h&gt;
using namespace posit;
int main() {

    cout &lt;&lt; &quot;This demo shows the use of deep initialization of a posit&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;and the PositTrait class&quot; &lt;&lt; endl;

	using real = Posit&lt;int8_t, 8, 0, uint16_t, PositSpec::WithNan&gt;;
	    
	using PT = PositTrait&lt;int8_t,8,0,PositSpec::WithNan&gt;;
    
    // Let us create a posit, initialized to zero (POSIT_ZERO is not defined, being it equal to 0)
	real a(real::DeepInit(), 0);
	cout &lt;&lt; dec &lt;&lt; a &lt;&lt; &quot; -&gt; &quot; &lt;&lt; oct &lt;&lt; a &lt;&lt; endl;

    // Let us create another posit, initialized to 1
	real b(real::DeepInit(), PT::POSIT_ONE);
	cout &lt;&lt; dec &lt;&lt; b &lt;&lt; &quot; -&gt; &quot; &lt;&lt; oct &lt;&lt; b &lt;&lt; endl; 

    // Let us create another posit, initialized to two
	real c(real::DeepInit(), PT::POSIT_TWO);
	cout &lt;&lt; dec &lt;&lt; c &lt;&lt; &quot; -&gt; &quot; &lt;&lt; oct &lt;&lt; c &lt;&lt; endl; 
    
    // Let us create another posit, initialized to MAXPOS
	real d(real::DeepInit(), PT::POSIT_MAXPOS);	
	cout &lt;&lt; dec &lt;&lt; d &lt;&lt; &quot; -&gt; &quot; &lt;&lt; oct &lt;&lt; d &lt;&lt; endl; 

	// Let us create another posit, initialized to -1
	real e(real::DeepInit(), PT::POSIT_MONE);
	cout &lt;&lt; dec &lt;&lt; e &lt;&lt; &quot; -&gt; &quot; &lt;&lt; oct &lt;&lt; e &lt;&lt; endl; 

    // Loop for printing all the positive posits
    real counter(real::DeepInit(), 0); // 
	for (int i = 0; i &lt; 128; i++){
		cout &lt;&lt; dec &lt;&lt; i+1 &lt;&lt; &quot;: &quot; &lt;&lt; counter &lt;&lt; &quot; -&gt; &quot; &lt;&lt; oct &lt;&lt; counter &lt;&lt; endl;
		counter = counter.next();
    }

	return 0;

}
</code></pre>
<h2>Standard Template Library</h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

#include &quot;../../include/posit.h&quot; // include non-tabulated posits
using namespace posit;
int main() {

	//using real = Posit&lt;int8_t, 8, 3, uint16_t, PositSpec::WithNan&gt;;
    // using real = Posit&lt;int16_t, 16, 1, uint32_t, PositSpec::WithNan&gt;;
	using real = Posit&lt;int32_t, 32, 2, uint64_t, PositSpec::WithNan&gt;;
		
	// Let us define a vector of posits of length DIM
	const int DIM = 5;
	vector &lt;real&gt; v(DIM);

	v[0] = int(1);
	v[1] = int(2);
	v[2] = 0.52f;
	v[3] = 0.53f;
	v[4] = 0.50003f;

    // Let us print it on screen
	cout &lt;&lt; endl&lt;&lt; endl &lt;&lt; &quot;Vector v: &quot; &lt;&lt; endl;
	cout &lt;&lt; endl &lt;&lt; &quot;[ &quot;;
	for (int i = 0; i &lt; DIM; i++)
	   cout &lt;&lt; v[i] &lt;&lt;' ';
	cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;


    // Let us define a rectangular matrix of size DIM x (DIM-1)
	vector&lt;vector&lt;real&gt;&gt; M(DIM, std::vector&lt;real&gt;(DIM - 1));

    // Let us define a rectangular matrix of size DIM x (DIM-1)
	cout &lt;&lt; endl&lt;&lt; endl &lt;&lt; &quot;Matrix M: &quot; &lt;&lt; endl;
	for(int i = 0; i &lt; DIM; i++){
		for (int j = 0; j &lt; DIM - 1; j++) {
			M[i][j] = (i + j) + 0.2;
			cout &lt;&lt; float(M[i][j]) &lt;&lt; ' ';
		}
		cout &lt;&lt; endl;
	}	

	return 0;
}
</code></pre>
<h2>Eigen Library</h2>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include &quot;../../include/posit.h&quot;
#include&lt;cstdlib&gt;
#include&lt;Eigen/Dense&gt;
using namespace std;
int main() {

	
	// Step1. Create a 3-by-3 random matrix, filled with posits
	using myFloat = posit::Posit&lt;int32_t, 32, 0, uint32_t, posit::PositSpec::WithNan&gt;;
    Eigen::Matrix&lt;myFloat,3,3&gt; m;
    for(int i = 0; i &lt; 3; ++i) {
    	for(int j = 0; j &lt; 3; ++j) {
    		m(i,j) = myFloat((double(rand()%200))/100);
    		std::cout &lt;&lt; m(i,j) &lt;&lt; &quot; &quot; ;
    	}
    	std::cout &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; std::endl;
	// Step2. compute its inverse
    Eigen::Matrix&lt;myFloat,3,3&gt; minv = m.inverse();
	// Step3. print it on screen
    for(int i = 0; i &lt; 3; ++i) {
    	for(int j = 0; j &lt; 3; ++j) {
    		std::cout &lt;&lt; minv(i,j) &lt;&lt; &quot; &quot; ;
    	}
    	std::cout &lt;&lt; std::endl;
    }    
    std::cout &lt;&lt; std::endl;
	// Step4. check wether the product of the original matrix and its inverse gives the identity matrix
    Eigen::Matrix&lt;myFloat,3,3&gt; prod = m*minv;
    for(int i = 0; i &lt; 3; ++i) {
    	for(int j = 0; j &lt; 3; ++j) {
    		std::cout &lt;&lt; prod(i,j) &lt;&lt; &quot; &quot; ;
    	}
    	std::cout &lt;&lt; std::endl;
    }    
	return 0;
}
</code></pre>
<h2>Fast Fourier Transform</h2>
<pre><code class="language-c++">#include &lt;iostream&gt;

#include &quot;posit.h&quot;

typedef posit::Posit&lt;int32_t,32,2,uint32_t,posit::PositSpec::WithNan&gt; real;

constexpr unsigned int k = 8; /* for 2^8 = 256 points */
constexpr unsigned N =  (1 &lt;&lt; k); /* N-point FFT */

typedef struct{
  real Re;
  real Im;
}
complex;

#ifndef PI
#define PI real(3.14159265358979323846264338327950288)
#endif
void fft(complex * signal, const unsigned int n, complex * tmp) {
  if (n &gt; 1) {
    /* return if n =&lt; 0 */
    unsigned int k, m;
    complex z, w, *vo, *ve;
    ve = tmp;
    vo = tmp + n / 2;
    for (k = 0; k &lt; n / 2; k++) {
      ve[k] = signal[2 * k];
      vo[k] = signal[2 * k + 1];
    }
    fft(ve, n / 2, signal); // FFT on even-indexed elements of signal[]
    fft(vo, n / 2, signal); // FFT on odd-indexed elements of signal[]
    for (m = 0; m &lt; n / 2; m++) {
      w.Re = (std::cos((real(2) * PI * real(m) / real(n))));
      w.Im = -(std::sin((real(2) * PI * real(m) / real(n))));
      z.Re = w.Re * vo[m].Re - w.Im * vo[m].Im; /* Re(w*vo[m]) */
      z.Im = w.Re * vo[m].Im + w.Im * vo[m].Re; /* Im(w*vo[m]) */
      signal[m].Re = ve[m].Re + z.Re;
      signal[m].Im = ve[m].Im + z.Im;
      signal[m + n / 2].Re = ve[m].Re - z.Re;
      signal[m + n / 2].Im = ve[m].Im - z.Im;
    }
  }
  return;
}

// Program entry point.
int main() {
  complex signal[N], tmp[N];
  unsigned int k;
  /* Fill signal[] as the sum of two pure sine signals of known frequency */
  for (k = 0; k &lt; N; k++) {
     signal[k].Re = real(0.125) * std::cos((real(2) * PI * real(k) / real(N))) + real(0.5) * std::cos((real(2) * PI * real(10*k) / real(N)));
     signal[k].Im = real(0.125) * std::sin((real(2) * PI * real(k) / real(N))) + real(0.5) * std::cos((real(2) * PI * real(10*k) / real(N)));
  }
  /* Printing the generated signal (for reading it in Matlab)*/
  std::cout &lt;&lt; &quot;signal = [\n&quot;;
  for (k = 0; k &lt; N; k++) {
	 std::cout &lt;&lt; signal[k].Re &lt;&lt; &quot;+&quot; &lt;&lt; signal[k].Im &lt;&lt;&quot;i&quot; &lt;&lt; std::endl;
  }
  std::cout &lt;&lt; &quot;]; \n\n&quot;;
  std::cout &lt;&lt; &quot;Computing the FFT...\n&quot;;
  fft(signal, N, tmp); // Perform FFT, signal will have the result.
  std::cout &lt;&lt; &quot;Printing the module of the obtained FFT coefficients:\n\nabs_FFT = [\n&quot;;
  for (k = 0; k &lt; N; k++) {
	 std::cout &lt;&lt; std::sqrt((signal[k].Re*signal[k].Re+signal[k].Im*signal[k].Im)) &lt;&lt; std::endl;
  }
  std::cout &lt;&lt; &quot;];\n\nDone. Check whether the second module is 32 and the 11th is 128\n&quot;;
  std::cout &lt;&lt; &quot;2th: &quot; &lt;&lt; std::sqrt((signal[1].Re*signal[1].Re+signal[1].Im*signal[1].Im)) &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;11th: &quot; &lt;&lt; std::sqrt((signal[10].Re*signal[10].Re+signal[10].Im*signal[10].Im)) &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(all the others must be zero, or close to zero)\n\n&quot;;
  
  return 0;
}
</code></pre>
<h2>Logging</h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &quot;../../include/posit.h&quot;
using namespace std;
using namespace posit;

using myreal = Posit&lt;int16_t, 8, 0, uint16_t, PositSpec::WithNan&gt;;

/**
 * The posit class has a built-in value logger to trace  
 * the values that are assigned to the class during 
 * the execution of a given portion of code.
**/
int main() {
	myreal a;
	// 1. Enable the logger at the beginning of the portion of code to be traced
	myreal::_logger.setLogLevel(LogLevel::ALL);
	for(int i = 0; i &lt; 100; ++i) {
		a = myreal((double(i)/100));
	}

	// 2. Complete tracing by saving the traced values
	myreal::_logger.save(&quot;a_logged.txt&quot;);
}
</code></pre>
<h2>Pseudo-sigmoid</h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;posit.h&gt;
using namespace std;
using namespace posit;
using Xa = Posit&lt;int16_t, 16, 0, uint16_t, PositSpec::WithNan&gt;;
typedef Xa myfl;


myfl sigmoid(myfl x) {
	double a = double(x);
	return 1/(1+std::exp(-a));
}


int main() {
	myfl a[] = {myfl(0.90625f)
	 ,myfl(0.2f)
	 ,myfl(0.3f)
	 ,myfl(0.4f)
	 ,myfl(0.43f)};
	cout &lt;&lt; &quot;Number&quot; &lt;&lt; &quot;   &quot; &lt;&lt; &quot;Pseudosigmoid&quot; &lt;&lt; &quot;   &quot; &lt;&lt; &quot;Sigmoid  &quot; &lt;&lt; &quot;   &quot; &lt;&lt; &quot;Difference&quot; &lt;&lt; &quot;\n&quot;;
	for(int i = 0; i &lt; 5; ++i)
		cout &lt;&lt; a[i] &lt;&lt; &quot;   &quot; &lt;&lt; double(a[i].pseudosigmoid()) &lt;&lt; &quot;   &quot; &lt;&lt; double(sigmoid(a[i])) &lt;&lt; &quot;   &quot; &lt;&lt; double(sigmoid(a[i]))-double(a[i].pseudosigmoid())&lt;&lt; &quot;\n&quot;;
	for(int i = 0; i &lt; 5; ++i)
		cout &lt;&lt; -a[i] &lt;&lt; &quot;   &quot; &lt;&lt; double((-a[i]).pseudosigmoid()) &lt;&lt; &quot;   &quot; &lt;&lt; double(sigmoid(-a[i])) &lt;&lt; &quot;   &quot; &lt;&lt; double(sigmoid(-a[i]))-double((-a[i]).pseudosigmoid())&lt;&lt; &quot;\n&quot;;

	return 0;
}
</code></pre>
<h2>Pseudo-tanh</h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;posit.h&gt;
using namespace std;
using namespace posit;
using Xa = Posit&lt;int32_t,8,0,uint64_t,PositSpec::WithNan&gt;;
typedef Xa myfl;

template &lt;class T&gt;
T tanh(T x) {
	return std::tanh(double(x));
}


int main() {
	myfl a[] = {0.90625f,
	 			0.32312f,
	 			0.333543f,
	 			0.2132144f,
	 			0.5213f,
	 			-0.3f,
	 			-0.2f,
	 			-0.1f,
	 			0.43f};
	for(auto x: a)
		cout &lt;&lt; x &lt;&lt; &quot;  &quot; &lt;&lt; double(x.pseudotanh()) &lt;&lt; &quot;  &quot; &lt;&lt; tanh(x) &lt;&lt; std::endl;
	return 0;
	
}
</code></pre>
<h2>Fused Operations</h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
#include &lt;posit.h&gt; // include non-tabulated posits
using namespace posit;

int main() {
	
	using ptype = Posit&lt;int8_t, 8, 0, uint32_t, PositSpec::WithInfs&gt;;
    using paccum = Posit&lt;int16_t,16,0,uint32_t, PositSpec::WithNan&gt;;

	std::vector&lt;ptype&gt; a{ptype(1.f),ptype(1.f),ptype(1.f),ptype(1.f),ptype(1.f),ptype(1.f)};      // constucts a posit, using a float literal
	std::vector&lt;ptype&gt; b{ptype(1.f),ptype(1.f),ptype(1.f),ptype(1.f),ptype(1.f),ptype(1.f)};      // constucts a posit, using a float literal
    paccum res(0);

    auto pres = posit::math::fma_dot(a.begin(),b.begin(),a.size(),res);

    std::cout &lt;&lt; pres &lt;&lt; std::endl;
	return 0;

}
</code></pre>
<h2>Hardware backend example</h2>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
#include &lt;posit.h&gt;
using namespace posit;
#include &lt;iomanip&gt;


int main() {
    using PPEMU = Posit&lt;int32_t, 32, 2, uint32_t, PositSpec::WithInfs&gt;;
    using PP = Posit&lt;int32_t, 32, 2, BackendXPosit&lt;int32_t,PPEMU&gt;, PositSpec::WithInfs&gt;;
    PP OneHalf(0.5f);
    std::cout &lt;&lt; OneHalf &lt;&lt; std::endl;
    return 0;
}
</code></pre>
</main></div></div></div></section></div><footer class="footer"><p>Documentation for cppposit 1.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.1-hdocInternal on 2023-08-03T08:41:33 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>